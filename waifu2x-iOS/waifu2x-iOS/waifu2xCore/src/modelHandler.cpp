/*
 * modelHandler.cpp
 *   (ここにファイルの簡易説明を記入)
 *
 *  Created on: 2015/05/24
 *      Author: wlamigo
 *
 *   (ここにファイルの説明を記入)
 */

#include "modelHandler.hpp"
// #include <iostream> in modelHandler.hpp
#include <fstream>
#include <thread>

namespace w2xc
{
    int Model::getNInputPlanes() {
        return nInputPlanes;
    }
    
    int Model::getNOutputPlanes() {
        return nOutputPlanes;
    }
    
    bool Model::filter(std::vector <cv::Mat> &inputPlanes,
                       std::vector <cv::Mat> &outputPlanes) {
        if (inputPlanes.size() != nInputPlanes) {
            std::cerr << "Error : Model-filter : \n"
            "number of input planes mismatch." << std::endl;
            std::cerr << inputPlanes.size() << ","
		          << nInputPlanes << std::endl;
            return false;
        }
        
        outputPlanes.clear();
        for (int i = 0; i < nOutputPlanes; i++) {
            outputPlanes.push_back(cv::Mat::zeros(inputPlanes[0].size(), CV_32FC1));
        }
        
        int nJob = modelUtility::getInstance().getNumberOfJobs();
        
        // filter job issuing
        std::vector <std::thread> workerThreads;
        int worksPerThread = nOutputPlanes / nJob;
        for (int idx = 0; idx < nJob; idx++) {
            if (!(idx == (nJob - 1) && worksPerThread * nJob != nOutputPlanes)) {
                workerThreads.push_back(
                                        std::thread(&Model::filterWorker, this,
                                                    std::ref(inputPlanes), std::ref(weights),
                                                    std::ref(outputPlanes),
                                                    static_cast <unsigned int>(worksPerThread * idx),
                                                    static_cast <unsigned int>(worksPerThread)));
            }
            else {
                // worksPerThread * nJob != nOutputPlanes
                workerThreads.push_back(
                                        std::thread(&Model::filterWorker, this,
                                                    std::ref(inputPlanes), std::ref(weights),
                                                    std::ref(outputPlanes),
                                                    static_cast <unsigned int>(worksPerThread * idx),
                                                    static_cast <unsigned int>(nOutputPlanes
                                                                               - worksPerThread * idx)));
            }
        }
        // wait for finishing jobs
        for (auto& th : workerThreads) {
            th.join();
        }
        
        return true;
    }
    
    bool Model::loadModelFromJSONObject(picojson::object &jsonObj) {
        // nInputPlanes,nOutputPlanes,kernelSize have already set.
        
        int matProgress = 0;
        picojson::array &wOutputPlane = jsonObj["weight"].get <picojson::array>();
        
        // setting weight matrices
        for (auto && wInputPlaneV : wOutputPlane) {
            picojson::array &wInputPlane = wInputPlaneV.get <picojson::array>();
            
            for (auto && weightMatV : wInputPlane) {
                picojson::array &weightMat = weightMatV.get <picojson::array>();
                cv::Mat writeMatrix = cv::Mat::zeros(kernelSize, kernelSize,
                                                     CV_32FC1);
                
                for (int writingRow = 0; writingRow < kernelSize; writingRow++) {
                    auto& weightMatRowV = weightMat.at(writingRow);
                    picojson::array &weightMatRow = weightMatRowV.get <
                    picojson::array>();
                    
                    for (int index = 0; index < kernelSize; index++) {
                        writeMatrix.at <float>(writingRow, index) =
                        weightMatRow[index].get <double>();
                    } // for(weightMatRow) (writing 1 row finished)
                } // for(weightMat) (writing 1 matrix finished)
                
                weights.at(matProgress) = std::move(writeMatrix);
                matProgress++;
            } // for(wInputPlane) (writing matrices in set of wInputPlane finished)
        } //for(wOutputPlane) (writing all matrices finished)
        
        // setting biases
        picojson::array biasesData = jsonObj["bias"].get <picojson::array>();
        for (int index = 0; index < nOutputPlanes; index++) {
            biases[index] = biasesData[index].get <double>();
        }
        
        return true;
    }
    
    bool Model::filterWorker(std::vector <cv::Mat> &inputPlanes,
                             std::vector <cv::Mat> &weightMatrices,
                             std::vector <cv::Mat> &outputPlanes, unsigned int beginningIndex,
                             unsigned int nWorks) {
        cv::ocl::setUseOpenCL(false); // disable OpenCL Support(temporary)
        
        cv::Size ipSize = inputPlanes[0].size();
        // filter processing
        // input : inputPlanes
        // kernel : weightMatrices
        for (int opIndex = beginningIndex; opIndex < (beginningIndex + nWorks);
             opIndex++) {
            int wMatIndex = nInputPlanes * opIndex;
            cv::Mat outputPlane = cv::Mat::zeros(ipSize, CV_32FC1);
            cv::UMat uIntermediatePlane = outputPlane.getUMat(cv::ACCESS_WRITE); // all zero matrix
            
            for (int ipIndex = 0; ipIndex < nInputPlanes; ipIndex++) {
                cv::UMat uInputPlane = inputPlanes[ipIndex].getUMat(cv::ACCESS_READ);
                cv::UMat weightMatrix = weightMatrices[wMatIndex + ipIndex].getUMat(cv::ACCESS_READ);
                cv::UMat filterOutput = cv::UMat(ipSize, CV_32FC1);
                
                cv::filter2D(uInputPlane, filterOutput, -1, weightMatrix, cv::Point(-1, -1), 0.0, cv::BORDER_REPLICATE);
                
                cv::add(uIntermediatePlane, filterOutput, uIntermediatePlane);
            }
            
            cv::add(uIntermediatePlane, biases[opIndex], uIntermediatePlane);
            cv::UMat moreThanZero = cv::UMat(ipSize, CV_32FC1, 0.0);
            cv::UMat lessThanZero = cv::UMat(ipSize, CV_32FC1, 0.0);
            cv::max(uIntermediatePlane, 0.0, moreThanZero);
            cv::min(uIntermediatePlane, 0.0, lessThanZero);
            cv::scaleAdd(lessThanZero, 0.1, moreThanZero, uIntermediatePlane);
            outputPlane = uIntermediatePlane.getMat(cv::ACCESS_READ);
            outputPlane.copyTo(outputPlanes[opIndex]);
        } // for index
        
        return true;
    }
    
    modelUtility *modelUtility::instance = nullptr;
    
    modelUtility& modelUtility::getInstance() {
        if (instance == nullptr) {
            instance = new modelUtility();
        }
        return *instance;
    }
    
    bool modelUtility::generateModelFromJSON(const std::string &fileName, std::vector <std::unique_ptr <Model>> &models) {
        std::ifstream jsonFile;
        
        jsonFile.open(fileName);
        if (!jsonFile.is_open()) {
            std::cerr << "Error : couldn't open " << fileName << std::endl;
            return false;
        }
        
        picojson::value jsonValue;
        jsonFile >> jsonValue;
        std::string errMsg = picojson::get_last_error();
        if (!errMsg.empty()) {
            std::cerr << "Error : PicoJSON Error : " << errMsg << std::endl;
            return false;
        }
        
        picojson::array& objectArray = jsonValue.get <picojson::array>();
        for (auto && obj : objectArray) {
            std::unique_ptr <Model> m = std::unique_ptr <Model>(
                                                                new Model(obj.get <picojson::object>()));
            models.push_back(std::move(m));
        }
        
        return true;
    }
    
    bool modelUtility::setNumberOfJobs(int setNJob) {
        if (setNJob < 1) return false;
        nJob = setNJob;
        return true;
    }
    
    int modelUtility::getNumberOfJobs() {
        return nJob;
    }
    
    bool modelUtility::setBlockSize(cv::Size size) {
        if (size.width < 0 || size.height < 0) return false;
        blockSplittingSize = size;
        return true;
    }
    
    bool modelUtility::setBlockSizeExp2Square(int exp) {
        if (exp < 0) return false;
        int length = std::pow(2, exp);
        blockSplittingSize = cv::Size(length, length);
        return true;
    }
    
    cv::Size modelUtility::getBlockSize() {
        return blockSplittingSize;
    }
    
    // for debugging
    
    void Model::printWeightMatrix() {
        for (auto && weightMatrix : weights) {
            std::cout << weightMatrix << std::endl;
        }
    }
    
    void Model::printBiases() {
        for (auto && bias : biases) {
            std::cout << bias << std::endl;
        }
    }
}
